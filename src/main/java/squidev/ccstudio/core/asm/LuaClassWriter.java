package squidev.ccstudio.core.asm;

import jdk.internal.org.objectweb.asm.Type;
import org.luaj.vm2.lib.LibFunction;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassWriter;

/**
 * A class writer that resolves classes to LibFunction if it can't guess their super class
 */
public class LuaClassWriter extends ClassWriter {
	private static final String LIBFUNCTION = Type.getInternalName(LibFunction.class);

	/**
	 * Constructs a new {@link org.objectweb.asm.ClassWriter} object and enables optimizations for
	 * "mostly add" bytecode transformations. These optimizations are the
	 * following:
	 * <p>
	 * <ul>
	 * <li>The constant pool from the original class is copied as is in the new
	 * class, which saves time. New constant pool entries will be added at the
	 * end if necessary, but unused constant pool entries <i>won't be
	 * removed</i>.</li>
	 * <li>Methods that are not transformed are copied as is in the new class,
	 * directly from the original class bytecode (i.e. without emitting visit
	 * events for all the method instructions), which saves a <i>lot</i> of
	 * time. Untransformed methods are detected by the fact that the
	 * {@link org.objectweb.asm.ClassReader} receives {@link org.objectweb.asm.MethodVisitor} objects that come from
	 * a {@link org.objectweb.asm.ClassWriter} (and not from any other {@link org.objectweb.asm.ClassVisitor}
	 * instance).</li>
	 * </ul>
	 *
	 * @param classReader the {@link org.objectweb.asm.ClassReader} used to read the original class. It
	 *                    will be used to copy the entire constant pool from the
	 *                    original class and also to copy other fragments of original
	 *                    bytecode where applicable.
	 * @param flags       option flags that can be used to modify the default behavior
	 *                    of this class. <i>These option flags do not affect methods
	 *                    that are copied as is in the new class. This means that the
	 *                    maximum stack size nor the stack frames will be computed for
	 *                    these methods</i>. See {@link #COMPUTE_MAXS},
	 *                    {@link #COMPUTE_FRAMES}.
	 */
	public LuaClassWriter(ClassReader classReader, int flags) {
		super(classReader, flags);
	}

	/**
	 * Constructs a new {@link org.objectweb.asm.ClassWriter} object.
	 *
	 * @param flags option flags that can be used to modify the default behavior
	 *              of this class. See {@link #COMPUTE_MAXS},
	 *              {@link #COMPUTE_FRAMES}.
	 */
	public LuaClassWriter(int flags) {
		super(flags);
	}

	/**
	 * Returns the common super type of the two given types. The default
	 * implementation of this method <i>loads</i> the two given classes and uses
	 * the java.lang.Class methods to find the common super class. It can be
	 * overridden to compute this common super type in other ways, in particular
	 * without actually loading any class, or to take into account the class
	 * that is currently being generated by this ClassWriter, which can of
	 * course not be loaded since it is under construction.
	 *
	 * @param type1 the internal name of a class.
	 * @param type2 the internal name of another class.
	 * @return the internal name of the common super class of the two given
	 * classes.
	 */
	@Override
	protected String getCommonSuperClass(String type1, String type2) {
		try {
			return super.getCommonSuperClass(type1, type2);
		} catch (RuntimeException e) {
			if (e.getMessage().contains("NotFound") && type1.contains("_LuaCompiled") && type2.contains("_LuaCompiled")) {
				return LIBFUNCTION;
			}
			return "java/lang/Object";
		}
	}
}
