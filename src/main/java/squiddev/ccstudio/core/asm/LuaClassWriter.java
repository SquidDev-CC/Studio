package squiddev.ccstudio.core.asm;

import org.luaj.vm2.lib.LibFunction;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.Type;

/**
 * A class writer that resolves classes to LibFunction if it can't guess their super class
 */
public class LuaClassWriter extends ClassWriter {
	private static final String LIBFUNCTION = Type.getInternalName(LibFunction.class);

	/**
	 * Constructs a new {@link org.objectweb.asm.ClassWriter} object.
	 *
	 * @param flags option flags that can be used to modify the default behavior
	 *              of this class. See {@link #COMPUTE_MAXS},
	 *              {@link #COMPUTE_FRAMES}.
	 */
	public LuaClassWriter(int flags) {
		super(flags);
	}

	/**
	 * Returns the common super type of the two given types. The default
	 * implementation of this method <i>loads</i> the two given classes and uses
	 * the java.lang.Class methods to find the common super class. It can be
	 * overridden to compute this common super type in other ways, in particular
	 * without actually loading any class, or to take into account the class
	 * that is currently being generated by this ClassWriter, which can of
	 * course not be loaded since it is under construction.
	 *
	 * @param type1 the internal name of a class.
	 * @param type2 the internal name of another class.
	 * @return the internal name of the common super class of the two given
	 * classes.
	 */
	@Override
	protected String getCommonSuperClass(String type1, String type2) {
		try {
			return super.getCommonSuperClass(type1, type2);
		} catch (RuntimeException e) {
			if (e.getMessage().contains("NotFound") && type1.contains("_LuaCompiled") && type2.contains("_LuaCompiled")) {
				return LIBFUNCTION;
			}
			return "java/lang/Object";
		}
	}
}
